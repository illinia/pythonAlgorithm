"""
1. 문제 이해
    1. 설명
        * 2^N * 2^N 인 2차원 배열을 Z 모양으로 탐색하려고 한다.
        * N > 1 인 경우 배열을 크기가 2^N-1 * 2^N-1 로 4등분한 다음 재귀적으로 순서대로 방문한다.
        * N 이 주어졌을 때 r 행 c 열을 몇 번째로 방문하는지 출력하기
    2. 제약사항
        * 1 <= N <= 15
        * 0 <= r, c < 2^N
2. 접근 방법
    * 같은 규칙이 반복되므로 분할정복으로 접근한다.
    * 특정 위치에 몇 번째로 접근하는지 알고싶으므로 4분할 했을 때 분할 위치에 따라 이전 분할면에서 몇 번 방문했는지 알 수 있음
    * 모든 위치를 방문하면서 카운트할 필요 없이 어떤 사분면에 위치했는지 아는 것 만으로도 이전 사분면 방문 횟수를 알 수 있음
    * 해당 위치가 어느 사분면에 있는지 확인하는 코드 필요
    * 방문 횟수를 카운트하는 변수 필요, 사분면 위치가 확인됐을 때 해당 카운트에 더하기
    * 반복하여 분할해야하므로 N 기준으로 -1을 해가면서 사분면의 위치를 계속 알아가면 됨
    * N = 3 인 예가 있으므로, 2^N-1 값을 기준으로 사분면 나누는 코드 작성하고, 해당 사분면 위치에 따라 2^N-1 * (사분면 위치 - 1)을 방문 카운트 해주면 됨
    * 최초 구하려는 행, 열 위치는 분할할 때 마다 조정해줘야 하므로 예를 들어 2사분면이면 행의 위치는 동일, 열의 위치는 -2^N-1 해준다
    * 반복때마다 N 을 -1 해주고 N 이 0 이 되면 반복 종료
3. 코드 설계
    1. N, r, c 입력
    2. visited 방문 카운트 0으로 초기화
    3. N 이 0 이상이면 반복
        1. N 에 -1 해줌
        2. 나누는 사분면 사이즈(길이) size 2^(N-1) 로 초기화
        3. 사분면 확인하는 코드 조건 4개
            1. r 이 size 보다 작고 c 이 size 보다 작으면(1사분면)
                1. visited 에 0 더해주기
            2. r 이 size 보다 작고 c 가 size 보다 같거나 크면(2사분면)
                1. visited 에 size 더해주기
                2. c 에 -size 해주기
            3. r 이 size 보다 같거나 크고 c 가 size 보다 작으면(3사분면)
                1. visited 에 size * 2 더해주기
                2. r 에 -size 해주기
            4. r 이 size 보다 같거나 크고 c 가 size 보다 같거나 크면(4사분면)
                1. visited 에 size * 3 더해주기
                2. r 에 -size 해주기
                3. c 에 -size 해주기
    4. visited 출력
"""
N, r, c = map(int, input().split())
visited = 0

while N >= 0:
    N -= 1
    size = 2 ** N

    if r < size and c < size:
        visited += 0
    elif r < size and c >= size:
        visited += size ** 2 * 1
        c -= size
    elif r >= size and c < size:
        visited += size ** 2 * 2
        r -= size
    else:
        visited += size ** 2 * 3
        r -= size
        c -= size

print(visited)