"""
0. 시간 복잡도를 보고 무조건 먼저 완전 탐색으로 풀 수 있는지 확인하는 습관을 가지기
1. 문제 이해
    1. 설명
        * 리모컨에 버튼이 0 부터 9 까지 있고 +, - 가 있다.
        * + 를 누르면 채녈이 +1 되고 - 를 누르면 -1 된다. 채널 0에서 -를 누르면 그대로이다. 채널은 무한대만큼 있다.
        * 이동하려는 채널은 N 이고 어떤 버튼이 고장났는지 주어졌을 때 최소 몇 번 눌러야 하는지 구하기
        * 현재 채널은 100 번이다
    2. 제약사항
        * 0 <= N <= 500,000
        * 0 <= 고장난 버튼의 갯수 M <= 10
        * 고장난 버튼이 있으면 배열로 주어진다
2. 접근 방법
    * 채널 갯수는 무한대이고 이동하려는 최대 채널은 500,000 이므로 1,000,000 범위까지 탐색
    * 백만번 탐색을 해도 시간 복잡도에는 문제없음
    * 최솟값 비교를 위해 현재 채널에서 +, - 만을 이용해서 왔다고 가정한 값을 저장
    * 0부터 1,000,000 까지 반복하여 탐색, 반복중인 값을 숫자 버튼으로 만들 수 있는지 확인하기 위해 고장난 버튼 리스트에 포함되어 있는지 확인
    * 모든 자리를 확인하고 확인한 자리가 마지막 자리였을 경우 최솟값 계산을 해준다(버튼 누르는 횟수 = 버튼 리스트 길이 + 이동한 채널과 목표 채널의 차를 절댓값 계산)
3. 코드 설계
    1. N, M, 입력 고장난 버튼(buttons) 리스트 선언
    2. M이 0이 아니라면 고장난 버튼 리스트 입력
    3. 현재 채널 100으로 초기화, 최솟값 결과를 현재 채널 - 목표 채널 결과를 절댓값 계산한 값으로 초기화
    4. 0부터 1,000,000 까지 반복
        1. 해당 숫자를 문자열 리스트로 변환
        2. 문자열 리스트 길이만큼 반복
            1. 해당 문자가 고장난 버튼 리스트에 있으면 반복문 탈출
            2. 없으면 현재 인덱스가 해당 문자열 마지막 인덱스인지 확인하고
            3. 마지막 인덱스이면(모든 숫자가 고장난 숫자가 아님) 최솟값 변수에 현재 최솟값과 버튼을 누르는 횟수, (목표 채널 - 이동한 채널) 절댓값을 더한 값중 최솟값을 저장
    5. 최솟값 출력
"""
N = int(input())
M = int(input())
buttons = {}

if M != 0:
    brokens = list(map(str, input().split()))
    for b in brokens:
        buttons[b] = True

current = 100
min_value = abs(current - N)

for i in range(1_000_001):
    nums_list = list(str(i))

    for j in range(len(nums_list)):
        if nums_list[j] in buttons:
            break
        elif j == len(nums_list) - 1:
            min_value = min(min_value, j + 1 + abs(N - i))

print(min_value)