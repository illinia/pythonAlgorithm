"""
1. 문제 이해
    1. 설명
        * N x M 크기 미로, 가장 왼쪽 윗 방 (1, 1) 가장 오른쪽 아랫 방 (N, M)
        * 이동은 아래, 오른쪽, 대각선 아래
        * 이동시 방에 있는 사탕을 가져간다
        * 가져올 수 있는 사탕의 최댓값
    2. 제약사항
        * 1 <= N, M <= 1,000
        * N 개의 줄에 M 개의 숫자, 0 <= 사탕 숫자 <= 100
2. 접근 방식
    * 매 이동시의 최댓값을 계산하는 dp
    * 최대 그래프의 크기는 1,000,000 개이고 최대 같은 위치에 3번 방문한다 해도 시간 초과되지 않는다
    * 모든 그래프 노드를 방문하고, 방문시 갈 수 있는 노드들의 dp 테이블 값에 최대값을 넣으면 된다
    * 현재 노드에서 아래, 오른쪽, 아래 대각선 방향으로 방문하고, 방문시 방문한 노드의 사탕 갯수 + 현재 노드 dp 값 중 최댓값을 방문한 노드의 dp 테이블에 저장
3. 코드 설계
    1. N, M 입력, 그래프 리스트 N 길이에 빈 리스트들로 초기화
    2. N 만큼 반복
        1. 입력값 그래프에 저장
    3. 0 부터 N - 1 만큼 반복
        1. 0 부터 M - 1 만큼 반복
            1. 현재 위치(최초 0, 0)에서 갈 수 있는 노드들 방문
            2. 방문 조건은 0 <= <= N - 1, M - 1 (그래프 범위)
            3. 방문한 노드의 사탕 갯수 + 이전 노드의 dp 테이블 값, 방문한 노드의 dp 테이블 값 중 큰 값을 방문한 노드의 dp 테이블 값에 저장
    4. dp 마지막 값 출력
"""
from sys import stdin

N, M = map(int, stdin.readline().split())
dp = [[0 for _ in range(M + 1)] for _ in range(N + 1)]
graph = [list(map(int, stdin.readline().split())) for _ in range(N)]

for i in range(1, N + 1):
    for j in range(1, M + 1):
        dp[i][j] = max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + graph[i - 1][j - 1]

print(dp[N][M])
