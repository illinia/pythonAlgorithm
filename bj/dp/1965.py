"""
1. 문제 이해
    1. 설명
        * 상자가 일렬로 있고 크기가 숫자 배열로 주어진다.
        * 크기가 작은 상자는 뒤의 상자가 크키가 크면 뒤의 상자에 넣을 수 있다.
        * 한 번에 넣을 수 있는 최대 상자 갯수를 출력
    2. 제약사항
        * 1 <= n <= 1000
2. 접근 방법
    * 최대 크기를 구하는 문제이고 특정 위치의 상자에 들어갈 수 있는 최대 상자 갯수는 앞에 있는 상자들의 조합중 최대값이므로
    * 이전 결과를 저장하여 다시 사용하는 dp 로 해결할 수 있다.
    * 특정 위치의 상자에 들어가있는 상자들 최대 갯수를 구하기 위해선 해당 위치 상자보다 작은 상자들에 들어가있는 값 중 최댓값 + 1을 하면 구할 수 있다.
    * 두 번째 상자부터 순회하여 앞의 상자들 중 자신의 크기보다 작은 상자들에 들어가있는 상자 갯수 중 최댓값을 가져와서 + 1하여 자신의 값에 저장하면 된다.
    * O(N^2) 이지만 N의 최대값은 1000 이므로 충분
3. 코드 설계
    1. n 입력, 상자 배열 입력
    2. dp 테이블 길이는 상자 배열과 같게하고 0 으로 초기화
    3. 상자 배열 두번째 인덱스부터 반복, i
        1. 최댓값 0 으로 초기화
        2. 앞에 있는 상자들 인덱스 반복, j
            1. 자신(i 번째 상자 값)보다 작은 값의 상자(j 번째 상자)이면, dp 테이블에서 j 번째 상자와 최댓값을 비교해서 큰 값을 최댓값에 저장
        3. dp 테이블에 최댓값 저장
    4. dp 테이블 중 최댓값 출력
"""
n = int(input())
numbers = list(map(int, input().split()))

dp = [1] * n

for i in range(1, n):
    max_value = 0
    for j in range(i):
        if numbers[j] < numbers[i]:
            max_value = max(max_value, dp[j])
    dp[i] = max_value + 1

print(max(dp))